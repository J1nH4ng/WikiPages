import{f as d,D as t,c,o as a,as as i,b as p,H as s,w as n,a as h,at as k}from"./chunks/framework.Dr7m8lqR.js";const y=JSON.parse('{"title":"Docker 网络配置详解","description":"Docker 网络配置详解文档","frontmatter":{"title":"Docker 网络配置详解","editLink":true,"description":"Docker 网络配置详解文档","layout":"doc","head":[["meta",{"name":"keywords","content":"Linux, Docker, Cloud, CNCF, Network"}]],"outline":"deep","prev":{"text":null,"link":null},"next":{"text":null,"link":null}},"headers":[],"relativePath":"posts/7403161d.md","filePath":"docs/cloud/docker/docker-networks.md","lastUpdated":1749180568000}'),b={name:"posts/7403161d.md"};function g(u,e,A,m,D,x){const o=t("Mermaid"),r=t("NolebaseGitContributors"),l=t("NolebaseGitChangelog");return a(),c("div",null,[e[1]||(e[1]=i('<h1 id="docker-网络详解" tabindex="-1">Docker 网络详解 <a class="header-anchor" href="#docker-网络详解" aria-label="Permalink to &quot;Docker 网络详解&quot;">​</a></h1><div class="note custom-block github-alert"><p class="custom-block-title">前言：</p><p></p><p>Docker 网络是在 Docker 容器内实现网络通信和连接的重要组成部分。它提供了多种网络模式和配置选项，使得容器可以与其他容器、主机以及外部网络进行通信，在实际应用中，通过选择合适的网络类型和配置参数，可以构建高效、安全、可拓展的 Docker 网络解决方案。</p></div><h2 id="网络模式" tabindex="-1">网络模式 <a class="header-anchor" href="#网络模式" aria-label="Permalink to &quot;网络模式&quot;">​</a></h2><p>Docker run 创建 Docker 容器时，可以使用 <code>--net</code> 选项指定容器的网络模式，Docker 主要有以下四种网络模式：</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_0" checked="true" disabled="true"><label for="cbx_0"> bridge 模式</label></li><li class="task-list-item"><input type="checkbox" id="cbx_1" disabled="true"><label for="cbx_1"> host 模式</label></li><li class="task-list-item"><input type="checkbox" id="cbx_2" disabled="true"><label for="cbx_2"> none 模式</label></li><li class="task-list-item"><input type="checkbox" id="cbx_3" disabled="true"><label for="cbx_3"> container 模式</label></li></ul><p>不同的模式区别详解如下：</p><h3 id="bridge-模式" tabindex="-1">Bridge 模式 <a class="header-anchor" href="#bridge-模式" aria-label="Permalink to &quot;Bridge 模式&quot;">​</a></h3><p>bridge 模式（网桥模式）是 Docker 默认的网络模式，Docker 启动后会在宿主主机上创建一个名为 docker0 的虚拟网桥<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，处于七层网络模式的数据链路层，在我们之后创建的新的 Docker 容器时，如果不指定网络模式，Docker 则会通过 docker0 与主机的网络连接。</p><p>可以通过如下的命令查看 docker0 网卡的信息：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes rose-pine-dawn rose-pine-moon vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D7827E;--shiki-dark:#EA9A97;">docker</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> network</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> inspect</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> bridge</span><span style="--shiki-light:#286983;--shiki-dark:#3E8FB0;"> |</span><span style="--shiki-light:#D7827E;--shiki-dark:#EA9A97;"> jq</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> &#39;.[0] | {Name:.Name, Id:.Id, Driver:.Driver, IPAM:.IPAM.Config, Containers:.Containers, Options:.Options}&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在新的 Docker 容器内会有一张新的网卡生成，默认为 eth0，该网卡通过 veth 网络和 docker0 网卡进行通信，而 docker0 会与宿主机网卡进行通信，充当网桥的作用。此时在宿主机上观察网卡会发现网卡序号从 3 直接到 5，而所谓的 4 号网卡即容器内的 eth0 网卡。</p><p>其基本的网络结构如下所示：</p>',12)),(a(),p(k,null,{default:n(()=>[s(o,{id:"mermaid-58",class:"mermaid",graph:"---%0Atitle%3A%20docker%20bridge%20%E6%A8%A1%E5%BC%8F%0A---%0A%0Aarchitecture-beta%0A%20%20%20%20service%20network(logos%3Achrome)%5BNetwork%5D%0A%20%20%20%20%0A%20%20%20%20group%20bare(logos%3Aaws)%5BBare%20Metal%5D%0A%20%20%20%20%20%20%20%20service%20ens3p0(logos%3Aaws-eventbridge)%5Bifconfig%5D%20in%20bare%0A%20%20%20%20%20%20%20%20group%20docker0(logos%3Adocker)%5BDocker%5D%20in%20bare%0A%20%20%20%20%20%20%20%20%20%20%20%20junction%20net_point01%20in%20docker0%0A%20%20%20%20%20%20%20%20%20%20%20%20junction%20net_point02%20in%20docker0%0A%20%20%20%20%20%20%20%20%20%20%20%20junction%20net_point03%20in%20docker0%0A%20%20%20%20%20%20%20%20%20%20%20%20service%20eth00(logos%3Aaws-eventbridge)%5Bdocker0%20veth%5D%20in%20docker0%0A%20%20%20%20%20%20%20%20%20%20%20%20group%20docker1(logos%3Adocker)%5BDocker%20Container%5D%20in%20docker0%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20service%20eth01(logos%3Aaws-eventbridge)%5Beth0%5D%20in%20docker1%0A%20%20%20%20%20%20%20%20%20%20%20%20group%20docker2(logos%3Adocker)%5BDocker%20Container%5D%20in%20docker0%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20service%20eth02(logos%3Aaws-eventbridge)%5Beth0%5D%20in%20docker2%0A%20%20%20%20%0A%20%20%20%20eth01%3AB%20--%20T%3Anet_point01%0A%20%20%20%20eth02%3AB%20--%20T%3Anet_point02%0A%20%20%20%20net_point01%3AR%20--%20L%3Anet_point03%0A%20%20%20%20net_point02%3AL%20--%20R%3Anet_point03%0A%20%20%20%20net_point03%3AB%20--%20T%3Aeth00%0A%20%20%20%20eth00%3AB%20--%20T%3Aens3p0%0A%20%20%20%20ens3p0%3AB%20--%20T%3Anetwork%0A"})]),fallback:n(()=>e[0]||(e[0]=[h(" Loading... ")])),_:1})),e[2]||(e[2]=i('<p>在该模式下，不同容器、宿主机、互联网之间的通信可达性如下：</p><table tabindex="0"><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">容器 &lt;-&gt; 容器</th><th style="text-align:center;">容器 -&gt; 宿主</th><th style="text-align:center;">宿主 -&gt; 容器</th><th style="text-align:center;">容器 -&gt; 互联网</th><th style="text-align:center;">互联网 -&gt; 容器</th></tr></thead><tbody><tr><td style="text-align:center;">Bridge 网络</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:center;">端口关联</td></tr></tbody></table><p>这里的通信使用的是 IP 地址进行通信，在默认的 bridge 模式下，即 docker0 网卡并不会在容器间进行 DNS 解析功能，而解决方法很简单，即手动创建一个新的使用 bridge 驱动的网络：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes rose-pine-dawn rose-pine-moon vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D7827E;--shiki-dark:#EA9A97;">docker</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> network</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> create</span><span style="--shiki-light:#286983;--shiki-dark:#3E8FB0;"> -d</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> bridge</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> {bridge-name}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>将容器网络添加到新建的网卡中，只需要在创建容器时添加 <code>--network {bridge-name}</code> 即可。</p><p>而要删除新创建的网卡，使用如下命令：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes rose-pine-dawn rose-pine-moon vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D7827E;--shiki-dark:#EA9A97;">docker</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> network</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> rm</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> {bridge-name}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="tip custom-block github-alert"><p class="custom-block-title">备注：</p><p></p><p>默认的网卡无法被删除。</p></div><p>此时在容器内也可以通过 hostname 进行相互间的通信了，对于生产环境而言，可以遵循如下的建议：</p><ul><li>创建自定义的 bridge 网络而非使用默认网络</li><li>为关键服务分配静态 IP 地址（<code>--ip</code> 参数）</li><li>合理规划端口分配，避免冲突</li><li>定期清理未使用的网络资源</li></ul><h3 id="host-模式" tabindex="-1">Host 模式 <a class="header-anchor" href="#host-模式" aria-label="Permalink to &quot;Host 模式&quot;">​</a></h3><h3 id="none-模式" tabindex="-1">None 模式 <a class="header-anchor" href="#none-模式" aria-label="Permalink to &quot;None 模式&quot;">​</a></h3><h3 id="container-模式" tabindex="-1">Container 模式 <a class="header-anchor" href="#container-模式" aria-label="Permalink to &quot;Container 模式&quot;">​</a></h3><h2 id="防火墙配置" tabindex="-1">防火墙配置 <a class="header-anchor" href="#防火墙配置" aria-label="Permalink to &quot;防火墙配置&quot;">​</a></h2>',14)),s(r),s(l),e[3]||(e[3]=i('<hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.cnblogs.com/xiongzaiqiren/p/18177383/docker-network" target="_blank" rel="noreferrer">docker网络配置：bridge模式、host模式、container模式、none模式</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>',2))])}const v=d(b,[["render",g]]);export{y as __pageData,v as default};
