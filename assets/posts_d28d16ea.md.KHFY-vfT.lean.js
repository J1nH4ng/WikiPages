import{f as r,D as i,c as p,o as d,k as a,as as c,H as l,a as s,w as u}from"./chunks/framework.Dr7m8lqR.js";const x=JSON.parse('{"title":"Docker 的实现原理","description":"Docker 的实现原理详解文档","frontmatter":{"title":"Docker 的实现原理","editLink":true,"description":"Docker 的实现原理详解文档","layout":"doc","head":[["meta",{"name":"keywords","content":"Linux, Docker, Core"}]],"outline":"deep","prev":{"text":null,"link":null},"next":{"text":null,"link":null}},"headers":[],"relativePath":"posts/d28d16ea.md","filePath":"docs/cloud/docker/core-tech.md","lastUpdated":1747639371000}'),k={name:"posts/d28d16ea.md"};function m(h,e,b,N,g,C){const n=i("sapn"),o=i("NolebaseGitContributors"),t=i("NolebaseGitChangelog");return d(),p("div",null,[e[3]||(e[3]=a("h1",{id:"docker-的底层技术",tabindex:"-1"},[s("Docker 的底层技术 "),a("a",{class:"header-anchor",href:"#docker-的底层技术","aria-label":'Permalink to "Docker 的底层技术"'},"​")],-1)),e[4]||(e[4]=a("p",null,"Docker 的工作原理主要基于 Linux 内核的三大核心技术：",-1)),e[5]||(e[5]=a("ul",null,[a("li",null,"命名空间（Namespaces）"),a("li",null,"控制组（Cgroups）"),a("li",null,"联合文件系统（UnionFS）")],-1)),e[6]||(e[6]=a("h2",{id:"namespaces",tabindex:"-1"},[s("Namespaces "),a("a",{class:"header-anchor",href:"#namespaces","aria-label":'Permalink to "Namespaces"'},"​")],-1)),a("p",null,[e[1]||(e[1]=s("Namespaces 是 Linux 提供的")),l(n,{class:"marker-evy"},{default:u(()=>e[0]||(e[0]=[s("资源隔离机制")])),_:1}),e[2]||(e[2]=s("，Docker 利用以下几种 Namespace 来实现容器【虚拟环境】的效果："))]),e[7]||(e[7]=c('<ul><li>PID Namespace：隔离进程 ID 空间</li><li>NET Namespace：隔离网络接口、IP、端口等</li><li>IPC Namespace：隔离进程间通信</li><li>UTS Namespace：隔离主机名和域名</li><li>MNT Namespace：隔离文件系统挂载点</li><li>USER Namespace：隔离用户和权限</li></ul><p>通过这些机制，容器像是一个独立的系统，但其实只是主机上的一组被隔离的进程。</p><h2 id="cgroups" tabindex="-1">Cgroups <a class="header-anchor" href="#cgroups" aria-label="Permalink to &quot;Cgroups&quot;">​</a></h2><p>Cgroups 用于限制和统计容器对资源的使用：</p><ul><li>限制 CPU、内存、IO、网络带宽</li><li>做资源隔离和分配</li><li>防止某个容器耗尽系统资源</li></ul><p>例如：</p><p>使用如下命令现在最多使用 512 MB 内存：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes rose-pine-dawn rose-pine-moon vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D7827E;--shiki-dark:#EA9A97;">docker</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> run</span><span style="--shiki-light:#286983;--shiki-dark:#3E8FB0;"> -m</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> 512m</span><span style="--shiki-light:#EA9D34;--shiki-dark:#F6C177;"> nginx</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="unionfs" tabindex="-1">UnionFS <a class="header-anchor" href="#unionfs" aria-label="Permalink to &quot;UnionFS&quot;">​</a></h2><p>UnionFS 文件系统（如 OverlayFS）支持将多个目录挂载到同意目录，Docker 的镜像就构建于此之上。</p><ul><li>每一层都是只读的增量文件系统</li><li>最上层是可写层（容器运行时）</li><li>镜像层复用，实现快速构建和启动</li></ul>',11)),l(o),l(t)])}const f=r(k,[["render",m]]);export{x as __pageData,f as default};
